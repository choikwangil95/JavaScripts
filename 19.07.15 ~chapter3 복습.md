# Nomard Coder

### NPM (Node Package Manager)
package를 다운받는곳? 음..</br>
Node.js 다운받으면 자동으로 NPM이 다운받아진다

#### NPM으로 프로젝트 시작하기
npm이 정해놓은 방식대로 해줘야함</br>
- 1 ) `npm init` 하고 정보를 입력해주면 package.json이 생성됨
- 2 ) package.json은 JS에서 정보를 담는 방식(JSON 은 JS를 저장하는 것)으로 다음과 같음
```json
{
  "name": "wetube",
  "version": "1.0.0",
  "description": "Cloning Youtube with Vanilla and NodeJS",
  "main": "index.js",
  "author": "Choi Kwangil",
  "license": "ISC",
  "dependencies": {
    "@babel/core": "^7.5.4",
    "@babel/node": "^7.5.0",
    "@babel/preset-env": "^7.5.4",
    "body-parser": "^1.19.0",
    "cookie-parser": "^1.4.4",
    "express": "^4.17.1", // npm install express로 package에 설치된 것
    "helmet": "^3.18.0",
    "morgan": "^1.9.1"
  },
  "scripts": {
    "start": "nodemon --exec babel-node init.js --delay 2"  // 명령문으로 start를 해주면 뒤의 값을 입력하도록 해서 편하게 run 해주도록 한것 (npm start라고 해주면 됌)
  },
  "devDependencies": { // npm install nodemon -D 라고 해주면 프로젝트에 필요하지 않은 하지만 개발자에게만 적용하고싶은 package를 다운함
    "nodemon": "^1.19.1"
  }
}
```
- 3 ) express 설치 (package.json 이 있는 폴더에서 해줘야함
`npm install express` </br>
node_modules 폴더도 다운되는데 이건 framework가 받아진거고 이걸 이용하는 것<br/>
package가 어썸한건 package에 저장만해도 저 많은 modules들을 이동 안해됨
걍 `npm install`만 해줘도 package에 있는 정보를 토대로 다 저장됨

### Create express server
- 1 ) gitignore 파일을 만들어 node_modules과 package-lock.json을 push하지 않도록함
```json
node_modules

# Logs    // 이건 gitignore의 표준임 구글링
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

package-lock.json
```
- 2 ) git에 올려줌
`git init`</br>
`git clone <url> <folder>`</br>
`git remote add origin <url>`</br>
`git add .`</br>
`git commit -m '설명'`</br>
`git push origin master`</br>

- 3 ) express 문서에서 복붙 // 이게 기본 작동 방식이고~
```javascripts

const express = require('express'); // node modules에서 express폴더를 가져옴(import 해준 것임) express는 server를 만들어줄 수 있는 코드들임 
const app = express();  // express 실행시킨거
const PORT = 4000;

function handleListening() {
  console.log(`Listening on: http://localhost:&{PORT}`)
}

function handleHome(req, res) {
  res.send(" Hello form Home~ ");
}

function handleProfile(req, res) {
  res.send("THis is my profile");
}

app.listen(PORT, handleListening); //port 4000 으로 서버를 만든것
app.get('/', handleHome);
app.get('/profile', handleProfile);

// url이 호출될때는 일반적으로 유저로부터 req를 받으면 웹에서 res를 통해 반응해준다, 응답이 없다면 영원히 req만 있는 loading 상태일 것
```

- 4 ) 

### ES6 on NodeJS using Babel
bable은 최신 JS를 예전 JS로 변환시켜줌 <br/>
- 1 ) 설치 : `npm install@babel/node` / `npm install@babel/preset-env`
- 2 ) 적용 : .babelrc 파일을 만들어주고 적용해준다<br/>
그러면 JS를 새롭게 작성할 수 있음
```javascripts
const express = require('express');

function handleListening() {
  console.log(`Listening on: http://localhost:&{PORT}`)
}

이걸

import express from "express"; 이렇게 쓸 쑤 있음 

const handleListening = (req, res) => console.log(`Listening on: http://localhost:&{PORT}`) // JS arrow function

이렇게 쓸 쑤 있음 
```
- 3 ) package.json에서 start를 `babel-node index.js`로 바꿔줌
- 4 ) 실행할 떄 마다 새로고침 안하도록 nodemon이라는 package를 설치해줌

### middleware
middleware는 req와 res 사이에 존재하는 delay로 보통 인증, 로그확인 등등 req와 res 사이에 작동할 무언가가 필요할 때 사용함. 
```javascripts
const handleHome = (req, res) => res.send("home here");
const betweenHome = (req, res, next) => {
  console.log("Between");
  next();
};

app.use(betweenHome); // 이렇게 해주면 모든 route에 대해서 모두 middleware가짐

app.get("/", betweenHome ,handleHome);
```
<br/>
#### middleware 는 여러가지 다운받을 수 있음<br/>
- 1 ) morgan : loggin을 알 수 있음
- 2 ) helmet : express 보안이라함
#### middleware는 res반응 시 next로 가지 못하고 끝나므로 유의

### Router는 django에서 include같은 것임
```javascript
# app.js

import express from "express";
import morgan from "morgan";
import helmet from "helmet";
import cookieParser from "cookie-parser";
import bodyParser from "body-parser";
import { userRouter } from "./router";

// express server 호출
const app = express();

// get의 함수들
const handleHome = (req, res) => res.send("Hello from Home!");
const handleProfile = (req, res) => res.send("This is my profile");

// 여기서부터 middleware
app.use(cookieParser());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended : true}));
app.use(helmet());  // 보안?
app.use(morgan("dev")); // morgan은 어떤 종류의 접속인지 logging을 하여 알려준다

// URL을 get하는 Method로 브라우저에 요청 한 것 
app.get('/',handleHome) ; 
app.get('/profile', handleProfile) ;
app.use("/user", userRouter);   // /user 에 userRouter을 주면 django에 include처럼 userRouter로 가서 route가 작동됨

export default app; // 다른 파일에서 app을 사용할 수 있도록 app을 수출해준다
```

```javascript
# router.js

import express from "express";

export const userRouter = express.Router();

userRouter.get("/", (req, res) => res.send("user index"));
userRouter.get("/edit", (req, res) => res.send("user edit"));
userRouter.get("/password", (req, res) => res.send("user password"));
```
